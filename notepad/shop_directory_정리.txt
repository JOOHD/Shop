★ ★★★★ 서버는 항상 신뢰하지 않는 데이터를 검증해야 하는 존재 ★★★★★

★ 회원(Member)

사용자 관점								개발자 관점
"내가 로그인했으니까 내 정보는 나만 수정할 수 있다?"    "토큰이나 세션이 조작되거나 탈취되면 다른 사람 정보도 수정 가능 해질 수 있다. 토큰 검증, 권한 확인은 필수"
"비밀번호는 바꿀 때만 신경 쓰면 된다?"			      "비밀번호 변경 요청은 반드시 현재 비밀번호 확인 + 인증 절차 필요. 이메일 인증, SMS 인증도 추가"
"프로필 수정하면 끝 아닌가?"					      "권한 없는 사용자도 접근 가능한 API라며 ㄴ누구나 수정 가능할 수도 있다. 반드시 인증된 사용자만 접근 가능하게 해야"
"회원 탈퇴하면 데이터 삭제되겠지?"			      "정말 삭제할 건지, 복구 불가능한 건지, 남아있는 데이터가 있는지 고민 필요. GDPR 준수, 로그 기록 유지 등도 고려"

★ 장바구니 (Cart)

사용자 관점								개발자 관점
"내 장바구니만 선택하겠지?"					     "혹시라도 다른 사람 장바구니 ID가 섞여 있으면 어떡하지?"
"내 정보는 수정 못 하게 막으면 되잖아?"			     "HTML에서 막아도 요청 데이터는 얼마든지 조작될 수 있어"
"내 정보니까 나만 접근 가능해!"				     "내 정보라 하더라도 서버에서 한 번 더 검증해야 안전해"
	
-> HTML의 disabled 속성은 UI 레벨 제한일 뿐이고, 중요한 검증은 반드시 서버에서 이루어져야 합니다.

★ Product (상품)

사용자 관점								개발자 관점
"상품 가격은 관리자만 바꿀 수 있겠지?"			"상품 등록/수정 API에 대한 권한 제어가 없으면 일반 사용자도 변경할 수 있음. [Role 기반 접근 제어] 철저하게 해야 함!"
"재고가 0이면 못 사겠지?"					"재고가 없는 상태에서도 주문 요청이 들어올 수 있음. 서버에서 [재고를 트랜잭션]으로 안전하게 차감하도록 동시성 제어 필요!"
"상품 이미지는 예쁘면 좋지!"					"업로드 이미지에 악성 코드가 포함될 수 있음. [확장자 및 MIME 타입 검증, 용량 제한, 바이러스 검사] 등 필요!"
"내가 선택한 옵션이면 당연히 가능한 옵션이지!"	"옵션이 유효한지 서버에서 반드시 검증해야 함. 프론트에서 조작된 옵션값이 들어와도 서버가 걸러야 함!"

★ Order (주문)

사용자 관점								개발자 관점
"내가 결제하면 주문 완료겠지!"				"결제 후 주문 등록 시점이 중요함. 결제가 성공했다고 해도 주문 DB에 저장 실패할 수 있음 → 트랜잭션 관리 & 보상 트랜잭션 필요!"
"주소는 내가 입력한 대로 가겠지?"				"배송지 주소가 올바른지 서버에서 기본적인 유효성 검사를 수행해야 함. 잘못된 데이터로 인한 배송 오류 방지!"
"쿠폰 할인 적용하면 알아서 되겠지?"			"쿠폰 유효성, 만료일, 사용 여부 등을 서버에서 반드시 검증. 클라이언트에서 금액을 조작해도 서버가 방어해야 함!"
"내가 주문한 거니까 내 주문 내역이겠지?"		"다른 사람의 주문 번호로 조회하면 노출될 수 있음. 주문 조회 시 member_id와 매칭해서 검증 필수!"


★ Payment (결제)
사용자 관점								개발자 관점
"결제 버튼 눌렀으니까 결제됐지!"				"클라이언트에서 결제 요청 후 실제 결제 내역이 결제 서버(Iamport, 토스페이 등)에 존재하는지 서버에서 한 번 더 검증 필요!"
"결제 금액은 정확하게 입력됐겠지?"			"결제 요청 전에 장바구니 금액과 주문 금액이 일치하는지 서버에서 체크 필요. 중간에 가격이 조작되면 위험!"
"환불 요청하면 당연히 환불 되겠지?"			"환불 요청 시, 결제 이력이 정확한지, 환불 금액이 적절한지 서버가 최종적으로 판단해야 함. 이중 환불 방지!"
"카드 정보는 안전하겠지?"					"카드 정보는 서버에 직접 저장 금지! 결제대행사를 통해 토큰화 처리하고 민감정보를 취급하지 않는 구조 설계 필요!"


★★★★★ 추가적으로 고려해야 되는 보안 관점 ★★★★★

💡 1. 인증(Authentication)과 인가(Authorization)

	인증만 신경쓰고 인가를 까먹으면?
	→ 로그인만 하면 아무 API나 다 호출 가능해짐
	→ Role / 권한 체크 확실하게!

💡 2. 데이터 무결성 검증

	- 프론트에서 넘어오는 데이터는 신뢰하지 않는다!
	- 할인 가격, 재고 수량, 배송비 등은 항상 서버 기준으로 재검증!

💡 3. 트랜잭션 처리와 동시성 이슈

	- 재고 차감, 포인트 차감은 동시성 제어 없으면 두 번 처리됨
	- 비관적 락(Pessimistic Lock) 또는 낙관적 락(Optimistic Lock) 고려!

💡4. 민감 데이터 암호화 / 마스킹

	- 주민등록번호, 카드번호, 계좌번호는
	- 저장/조회 시 암호화하거나 마스킹 처리
	(예시: 홍길동 → 홍**, 1234-56-789012 → 1234-56-****)

★ Shop Project (Cart, Order, Payment 관계성)

- Cart (장바구니) 
	역할 
		사용자 구매 상품을 임시로 담아두는 장소, 상품을 장바구니에 담고, 수량을 조정/삭제/추가
	관련 엔티티 
		cart : 사용자가 담은 상푸 정보(상품, 수량, 가격 등)을 포함
		member : 장바구니에 담긴 상품의 소유자(사용자)를 나타냄
		ProductManagement : 장바구니에 담긴 상품의 세부 정보를 관리.
	주요 흐름  
		1. 사용자는 상품을 장바구니에 담고, 이때 CartService 의 addCart 메서드를 통해 장바구니에 추가.
		2. 장바구니에 담긴 상품들은 CartRepository 를 통해 관리되며, ProductManagement 를 통해 각 상품의 옵션 정보도 관리된다.

- Order (주문)
	역할 
		사용자가 장바구니에 담긴 상품을 최종적으로 구매하는 단계, 사용자가 장바구니에서 선택할 상품에 대한 결제 준비 정보를 포함.
	관련 엔티티
		order : 실제 주문을 나타내며, 주문한 상품들과 해당 회원 정보를 포함한다.
		cart : 사용자가 장바구니에서 선택한 상품에 대한 정보를 가지고 있으며, OderService 는 createOrder 메서드로 장바구니에서 주문을 생성한다.
		member : 주문을 요청한 사용자를 나타내며, OrderService 는 사용자와 장바구니 정보를 바탕으로 주문 생성
	주요 흐름
		1. 사용자가 장바구니에서 상품을 선택한 후, OrderService 의 createOrder 메서드를 통해 주문을 생성.
		2. createOrder 메서드는 장바구니에서 사용자가 선택한 상품을 확인하고, 해당 상품에 대한 총 가격을 계산하여 임시 주문을 생성한다.
		3. 주문이 생성 시, orderConfirm 메서드(입력한 결제 정보 + 주문 정보) = 최종 주문을 생성하고, 이를 OrderRepository 에 저장.
				
- Payment (결제)
	역할 
		결제는 사용자가 주문한 상품에 대해 실제 금액을 지불하는 단계,
		결제 과정은 주문이 완료 후, 외부 결제 API(아임포트) or 내부 결제 시스템을 통해 금액 처리,
		결제 완료 후, Payment 정보가 저장된다.
	관련 엔티티
		외부 API 연동 (Import), 내부 결제 엔티티(Payment)
	주요 흐름
		1. 사용자가 주문을 완료하면, 결제 페이지로 이동.
		2. 결제 정보가 제출되면, 외부 결제 api 를 통해 결제가 진행된다. 
			결제 정보를 Payment 엔티티에 기록하고, 결제 상태를 업데이트한다.
		3. 결제 완료 후, Payment 정보를 기반으로 주문 상태가 업데이트되고, 결제 완료 정보를 포함한 주문 처리가 이루어진다.

★ 카테고리 간의 관계 흐름
	1. Cart -> Order
		- 사용자가 장바구니에 담은 상품은 최종 주문으로 이어진다.
			CartService 장바구니에 담긴 상품을 확인하고, 이를 기반으로 OrderService 주문 생성.
		- Cart 는 사용자가 선택한 상품과 관련된 정보를 저장, Orders 는 장바구니에 담긴 상품들을 바탕으로 최종 주문 생성
	2. Order -> Payment
		- 결제를 진행하기 위한 정보 제공, 주문이 생성 시, 결제를 위한 정보를 입력 + 외부 결제 API를 통해 결제 처리
		- 결제 완료 시, 결제 정보는 Payment 엔티티에 저장되고, 이 정보는 주문과 결합되어 주문 상태 업데이트
	3. 결제 완료 후
		- 결제가 완료되면, 주문 상태는 "결제 완료"로 업데이트되고, 배송이나 후속 처리 등의 작업이 진행

★★ 전역으로 적용되는 기능 ★★
@RequiresRole, globalException, ConstraintValidator 
	
★★★ 디렉토리 트리맵 ★★★
  global	
  	ㄴ authentication
		ㄴ config
			AppConfig
			CorsMvcConfig
			EmailConfig
			SecurityConfig
			SmtpAuthenticator
		ㄴ jwts
			Filter(JWT & Login)
			cookie & userDetails			
			util
			    cookie/password/JWT
		ㄴ oauth2
			Handle
			ResponseDto(google, naver, kakao, oauth2)	
  	ㄴ authorization
  	ㄴ config
		ㄴ RedisConfig
		ㄴ WebConfig
  	ㄴ exception
  	ㄴ image
  	ㄴ mail
  	ㄴ validation
  	ㄴ queries
		ㄴ QueryDSL
	
  address
	- 본 주소로 설정 시, 기존 기본 주소들을 한 번의 JPQL 업데이트로 효율적으로 해제.
  cart
	- 장바구니 담기(addCart) : 동일한 상품이 존재하면 수량/가격 update, 없으면 새로운 상품 추가.
  category
	- 트리구조(계층형) n + 1 문제 & parent categoryId 유무를 삼항연산자로 최상위, 자식 카테고리 구현.
  contentImgs
	- 이미지 파일을 서버에 저장하고, DB에 해당 경로를 기록하여 관리하며, 필요 시 이미지를 삭제하여 파일 시스템과 DB를 동기화.
  members
	- 회원 가입
		- 가입 시, 이메일 인증 토큰 생성 및 인증 메일 발송, 권한(일반/관리자) 구분, profile(마이페이지) 자동 생성.
		- 이미 존재하는 이메일 검증 후, Member + Profile 생성 및 저장 -> Transactional 처리.
	- 로그인	
		- 내부에서 인증 실패 및 비밀번호 불일치 체크, 토큰 처리 및 리턴 이후 Refresh 토큰 관리.
		- 이메일 인증/토큰 발급 로직이 보안과 연결되게 하여, 인증 우회가 불가하도록 구현.
	- 로그아웃
		- 클라이언트 쿠키에 저장된 refresh 토큰 검증 후, 서버의 Refresh Entity 삭제 및 쿠키 무효화
		- 쿠키 삭제와 Refresh 토큰 삭제가 동시에 되어야 재로그인 및 토큰 재발급.
	- 회원 정보
		- 로그인된 사용자의 정보 조회, memberId 를 통한 정보 가져오기, Profile Entity 로 추가 정보 반환.
		- 반환 필드 변경(Entity->DTO) 시, 서비스 레이어에서 DTO생성/변환 코드도 같이 수정 해야 됨.
  order
	- 상품/회원 정보를 바탕으로 서버에 임시 저장된 주문서와 사용자가 입력한 정보를 합쳐 최종 주문을 확정하고 저장.
  payment
	- 아임포트를 사용해 결제 요청과 응답을 처리하고, 결제 완료 후 상태를 업데이트하며, 주문 완료 후 세션 정보를 삭제하는 기능을 구현.
  product
	-
  productManagement
	-
  productThumbnail
	-
  profile
	-
  inquery
	-
  review
	-

★★★ JWTFilterV3 ★★★

JWTFilterV3 역할
AccessToken + RefreshToken 기반 인증을 처리합니다.

Authorization 헤더에서 AccessToken 추출

쿠키(refreshAuthorization)에서 RefreshToken 추출

AccessToken이 유효한 경우 → SecurityContextHolder에 인증 정보 등록

AccessToken이 만료되었더라도 RefreshToken이 유효하지 않으면 → 인증 없이 다음 필터로 이동

모든 인증은 내부에서 getAuthentication(token)을 통해 이루어집니다.




