★ ★★★★ 서버는 항상 신뢰하지 않는 데이터를 검증해야 하는 존재 ★★★★★

★ 회원(Member)

사용자 관점								개발자 관점
"내가 로그인했으니까 내 정보는 나만 수정할 수 있다?"    "토큰이나 세션이 조작되거나 탈취되면 다른 사람 정보도 수정 가능 해질 수 있다. 토큰 검증, 권한 확인은 필수"
"비밀번호는 바꿀 때만 신경 쓰면 된다?"			      "비밀번호 변경 요청은 반드시 현재 비밀번호 확인 + 인증 절차 필요. 이메일 인증, SMS 인증도 추가"
"프로필 수정하면 끝 아닌가?"					      "권한 없는 사용자도 접근 가능한 API라며 ㄴ누구나 수정 가능할 수도 있다. 반드시 인증된 사용자만 접근 가능하게 해야"
"회원 탈퇴하면 데이터 삭제되겠지?"			      "정말 삭제할 건지, 복구 불가능한 건지, 남아있는 데이터가 있는지 고민 필요. GDPR 준수, 로그 기록 유지 등도 고려"

★ 장바구니 (Cart)

사용자 관점								개발자 관점
"내 장바구니만 선택하겠지?"					     "혹시라도 다른 사람 장바구니 ID가 섞여 있으면 어떡하지?"
"내 정보는 수정 못 하게 막으면 되잖아?"			     "HTML에서 막아도 요청 데이터는 얼마든지 조작될 수 있어"
"내 정보니까 나만 접근 가능해!"				     "내 정보라 하더라도 서버에서 한 번 더 검증해야 안전해"
	
-> HTML의 disabled 속성은 UI 레벨 제한일 뿐이고, 중요한 검증은 반드시 서버에서 이루어져야 합니다.

★ Product (상품)

사용자 관점								개발자 관점
"상품 가격은 관리자만 바꿀 수 있겠지?"			"상품 등록/수정 API에 대한 권한 제어가 없으면 일반 사용자도 변경할 수 있음. [Role 기반 접근 제어] 철저하게 해야 함!"
"재고가 0이면 못 사겠지?"					"재고가 없는 상태에서도 주문 요청이 들어올 수 있음. 서버에서 [재고를 트랜잭션]으로 안전하게 차감하도록 동시성 제어 필요!"
"상품 이미지는 예쁘면 좋지!"					"업로드 이미지에 악성 코드가 포함될 수 있음. [확장자 및 MIME 타입 검증, 용량 제한, 바이러스 검사] 등 필요!"
"내가 선택한 옵션이면 당연히 가능한 옵션이지!"	"옵션이 유효한지 서버에서 반드시 검증해야 함. 프론트에서 조작된 옵션값이 들어와도 서버가 걸러야 함!"

★ Order (주문)

사용자 관점								개발자 관점
"내가 결제하면 주문 완료겠지!"				"결제 후 주문 등록 시점이 중요함. 결제가 성공했다고 해도 주문 DB에 저장 실패할 수 있음 → 트랜잭션 관리 & 보상 트랜잭션 필요!"
"주소는 내가 입력한 대로 가겠지?"				"배송지 주소가 올바른지 서버에서 기본적인 유효성 검사를 수행해야 함. 잘못된 데이터로 인한 배송 오류 방지!"
"쿠폰 할인 적용하면 알아서 되겠지?"			"쿠폰 유효성, 만료일, 사용 여부 등을 서버에서 반드시 검증. 클라이언트에서 금액을 조작해도 서버가 방어해야 함!"
"내가 주문한 거니까 내 주문 내역이겠지?"		"다른 사람의 주문 번호로 조회하면 노출될 수 있음. 주문 조회 시 member_id와 매칭해서 검증 필수!"


★ Payment (결제)
사용자 관점								개발자 관점
"결제 버튼 눌렀으니까 결제됐지!"				"클라이언트에서 결제 요청 후 실제 결제 내역이 결제 서버(Iamport, 토스페이 등)에 존재하는지 서버에서 한 번 더 검증 필요!"
"결제 금액은 정확하게 입력됐겠지?"			"결제 요청 전에 장바구니 금액과 주문 금액이 일치하는지 서버에서 체크 필요. 중간에 가격이 조작되면 위험!"
"환불 요청하면 당연히 환불 되겠지?"			"환불 요청 시, 결제 이력이 정확한지, 환불 금액이 적절한지 서버가 최종적으로 판단해야 함. 이중 환불 방지!"
"카드 정보는 안전하겠지?"					"카드 정보는 서버에 직접 저장 금지! 결제대행사를 통해 토큰화 처리하고 민감정보를 취급하지 않는 구조 설계 필요!"


★★★★★ 추가적으로 고려해야 되는 보안 관점 ★★★★★

💡 1. 인증(Authentication)과 인가(Authorization)

	인증만 신경쓰고 인가를 까먹으면?
	→ 로그인만 하면 아무 API나 다 호출 가능해짐
	→ Role / 권한 체크 확실하게!

💡 2. 데이터 무결성 검증

	- 프론트에서 넘어오는 데이터는 신뢰하지 않는다!
	- 할인 가격, 재고 수량, 배송비 등은 항상 서버 기준으로 재검증!

💡 3. 트랜잭션 처리와 동시성 이슈

	- 재고 차감, 포인트 차감은 동시성 제어 없으면 두 번 처리됨
	- 비관적 락(Pessimistic Lock) 또는 낙관적 락(Optimistic Lock) 고려!

💡4. 민감 데이터 암호화 / 마스킹

	- 주민등록번호, 카드번호, 계좌번호는
	- 저장/조회 시 암호화하거나 마스킹 처리
	(예시: 홍길동 → 홍**, 1234-56-789012 → 1234-56-****)


★★★★★ 결론 ★★★★★

너가 장바구니에서 느낀 건 정말 핵심 개념이야.
그걸 모든 도메인에 걸쳐 확장해서 생각하고 방어하는 게
진짜 시큐어한 백엔드의 시작이니까, 이 마인드 절대 놓치지 마! 🔥


Shop project main skill

  global
 	
  	authentication
		config
			AppConfig
			CorsMvcConfig
			EmailConfig
			SecurityConfig
			SmtpAuthenticator
		jwts
			DoFilter
			CookieService
			util
			    cookie/password/JWT
		oauth2
			Handle
			ResponseDto(google, naver, kakao, oauth2)	
  	authorization
  	config
		RedisConfig
		WebConfig
  	exception
  	image
  	mail
  	validation
  	queries
		QueryDSL
	
  address
	- 본 주소로 설정 시, 기존 기본 주소들을 한 번의 JPQL 업데이트로 효율적으로 해제.
  cart
	- 장바구니 담기(addCart) : 동일한 상품이 존재하면 수량/가격 update, 없으면 새로운 상품 추가.
  category
	- 트리구조(계층형) n + 1 문제 & parent categoryId 유무를 삼항연산자로 최상위, 자식 카테고리 구현.
  contentImgs
	- 이미지 파일을 서버에 저장하고, DB에 해당 경로를 기록하여 관리하며, 필요 시 이미지를 삭제하여 파일 시스템과 DB를 동기화.
  members
	- 회원 가입
		- 가입 시, 이메일 인증 토큰 생성 및 인증 메일 발송, 권한(일반/관리자) 구분, profile(마이페이지) 자동 생성.
		- 이미 존재하는 이메일 검증 후, Member + Profile 생성 및 저장 -> Transactional 처리.
	- 로그인	
		- 내부에서 인증 실패 및 비밀번호 불일치 체크, 토큰 처리 및 리턴 이후 Refresh 토큰 관리.
		- 이메일 인증/토큰 발급 로직이 보안과 연결되게 하여, 인증 우회가 불가하도록 구현.
	- 로그아웃
		- 클라이언트 쿠키에 저장된 refresh 토큰 검증 후, 서버의 Refresh Entity 삭제 및 쿠키 무효화
		- 쿠키 삭제와 Refresh 토큰 삭제가 동시에 되어야 재로그인 및 토큰 재발급.
	- 회원 정보
		- 로그인된 사용자의 정보 조회, memberId 를 통한 정보 가져오기, Profile Entity 로 추가 정보 반환.
		- 반환 필드 변경(Entity->DTO) 시, 서비스 레이어에서 DTO생성/변환 코드도 같이 수정 해야 됨.
  order
  payment
  product
  productManagement
  productThumbnail
  profile
  inquery
  review






